---
title: Nuxt避免内存泄露
navigation:
  icon: i-lucide-egg
---

## 主要原因分析

### 1. 日志输出过多（已转移到SLS中）
- 大量的 `console.log`、`console.error` 等调试日志在生产环境中持续输出
- 错误监控系统产生大量日志数据
- 性能监控插件在生产环境中仍然运行

### 2. 定时器未正确清理
- 多个组件中的 `setInterval` 和 `setTimeout` 没有在组件卸载时清理
- 错误监控系统的定时器持续运行
- 轮询机制没有适当的清理机制
```ts
const timer = setTimeout(() => {
  clearTimeout(timer)
}, 3000)

const timer2 = ref(null)

onMounted(() => {
  timer2.value = setInterval(() => {
    // 定时器逻辑
  }, 1000)
})

onUnmounted(() => {
  if (timer2.value) {
    clearInterval(timer2.value)
    timer2.value = null
  }
})
</script>
```

### 3. 事件监听器泄漏
- 全局事件监听器没有正确移除
- 组件事件监听器在组件卸载时没有清理
```ts
const event = useEvent()
event.emit(OPEN_AI_WINDOW, {
  agent: 'SC_TRANSLATION_BOT',
})
event.on(OPEN_AI_WINDOW, {
  agent: 'SC_TRANSLATION_BOT',
})
onMounted(() => {
  document.addEventListener('scroll', doScroll)
})
onUnmounted(() => {
  unwatch()
  document.removeEventListener('scroll', doScroll)
  event.off(OPEN_AI_WINDOW) // 组件环境
  event.cleanup() // 非组件环境警告
  goodsList.value = null
})
// components\ai-tools\AiGroup.vue
onClick() {
  event.emit(OPEN_AI_WINDOW, {
    agent: 'SC_TRANSLATION_BOT',
  })
  event.off(OPEN_AI_WINDOW)
},
```

### 4. Vue 响应式数据累积
- 大量的 `watch` 和 `watchEffect` 造成响应式数据累积
- 组件卸载时没有正确清理响应式依赖
```ts
import { onUnmounted, watch, watchEffect } from 'vue'

const stopWatch = watch(data, () => {
  // 监听逻辑
})

const stopWatchEffect = watchEffect(() => {
  // 监听逻辑
})

onUnmounted(() => {
  stopWatch()
  stopWatchEffect()
})
```
### 5. 声明大内存数据变量
```ts
let pageTKDRef = ref([])
onUnmounted(() => {
  pageTKDRef.value = null
})
```
### 6. 环境配置优化

#### Nuxt 配置优化 (`nuxt.config.ts`)
```typescript
// 生产环境禁用详细日志
nitro: {
  logLevel: mode === 'production' ? 0 : 2, // 生产环境禁用日志
  // 生产环境内存优化
  ...(mode === 'production' && {
    maxRequestBodySize: '10mb',
    timing: false,
    debug: false
  }),
  plugins: mode === 'production' ? [] : ['~/server/plugins/log-errors.ts']
}

// 生产环境禁用 sourcemap
build: {
  ...(mode === 'production' && {
    sourcemap: false, // 生产环境禁用sourcemap以节省内存
  })
}
```

#### Node.js 启动参数优化
```json
{
  "scripts": {
    "start": "NODE_OPTIONS=\"--max-old-space-size=4096 --expose-gc --optimize-for-size\" node .output/server/index.mjs"
  }
}
```

### 7. 组件内存管理

#### 定时器清理
```vue
<script setup>
const timer = ref(null)

onMounted(() => {
  timer.value = setInterval(() => {
    // 定时器逻辑
  }, 1000)
})

onUnmounted(() => {
  if (timer.value) {
    clearInterval(timer.value)
    timer.value = null
  }
})
</script>
```

#### 事件监听器清理
```vue
<script setup>
import { onUnmounted } from 'vue'

const handleScroll = () => {
  // 滚动处理逻辑
}

onMounted(() => {
  document.addEventListener('scroll', handleScroll)
})

onUnmounted(() => {
  document.removeEventListener('scroll', handleScroll)
})
</script>
```

#### 响应式数据清理
```vue
<script setup>
import { onUnmounted, watch, watchEffect } from 'vue'

const stopWatch = watch(data, () => {
  // 监听逻辑
})

const stopWatchEffect = watchEffect(() => {
  // 监听逻辑
})

onUnmounted(() => {
  stopWatch()
  stopWatchEffect()
})
</script>
```

### 8. 开发规范

#### 代码审查要点
1. 检查所有定时器是否在组件卸载时清理
2. 检查事件监听器是否正确移除
3. 检查 `watch` 和 `watchEffect` 是否在组件卸载时停止
4. 检查生产环境是否还有调试日志输出

#### 内存泄漏检测
```javascript
// 在开发环境中使用 Chrome DevTools 的 Memory 面板
// 1. 打开 Memory 面板
// 2. 选择 Heap snapshot
// 3. 执行操作（如页面切换、组件加载卸载）
// 4. 再次拍摄快照
// 5. 比较快照，查看是否有内存泄漏
```
