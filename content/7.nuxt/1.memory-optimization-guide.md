---
title: Nuxt内存优化指南
---

## 问题描述

项目部署在线上后出现内存持续升高的问题，最终导致 JavaScript 堆内存溢出。

## 主要原因分析

### 1. 日志输出过多
- 大量的 `console.log`、`console.error` 等调试日志在生产环境中持续输出
- 错误监控系统产生大量日志数据
- 性能监控插件在生产环境中仍然运行

### 2. 定时器未正确清理
- 多个组件中的 `setInterval` 和 `setTimeout` 没有在组件卸载时清理
- 错误监控系统的定时器持续运行
- 轮询机制没有适当的清理机制
```ts
const timer = setTimeout(() => {
  clearTimeout(timer)
}, 3000)

const timer2 = ref(null)

onMounted(() => {
  timer2.value = setInterval(() => {
    // 定时器逻辑
  }, 1000)
})

onUnmounted(() => {
  if (timer2.value) {
    clearInterval(timer2.value)
    timer2.value = null
  }
})
</script>
```

### 3. 事件监听器泄漏
- 全局事件监听器没有正确移除
- 组件事件监听器在组件卸载时没有清理
```ts
const event = useEvent()
event.emit(OPEN_AI_WINDOW, {
  agent: 'SC_TRANSLATION_BOT',
})
event.on(OPEN_AI_WINDOW, {
  agent: 'SC_TRANSLATION_BOT',
})
onMounted(() => {
  document.addEventListener('scroll', doScroll)
})
onUnmounted(() => {
  unwatch()
  document.removeEventListener('scroll', doScroll)
  event.off(OPEN_AI_WINDOW) // 组件环境
  event.cleanup() // 非组件环境警告
  goodsList.value = null
})
// components\ai-tools\AiGroup.vue
onClick() {
  event.emit(OPEN_AI_WINDOW, {
    agent: 'SC_TRANSLATION_BOT',
  })
  event.off(OPEN_AI_WINDOW)
},
```

### 4. Vue 响应式数据累积
- 大量的 `watch` 和 `watchEffect` 造成响应式数据累积
- 组件卸载时没有正确清理响应式依赖
```ts
import { onUnmounted, watch, watchEffect } from 'vue'

const stopWatch = watch(data, () => {
  // 监听逻辑
})

const stopWatchEffect = watchEffect(() => {
  // 监听逻辑
})

onUnmounted(() => {
  stopWatch()
  stopWatchEffect()
})
```
### 5. 声明大内存数据变量
```ts
let pageTKDRef = ref([])
onUnmounted(() => {
  pageTKDRef.value = null
})
```
### 6. 环境配置优化

#### Nuxt 配置优化 (`nuxt.config.ts`)
```typescript
// 生产环境禁用详细日志
nitro: {
  logLevel: mode === 'production' ? 0 : 2, // 生产环境禁用日志
  // 生产环境内存优化
  ...(mode === 'production' && {
    maxRequestBodySize: '10mb',
    timing: false,
    debug: false
  }),
  plugins: mode === 'production' ? [] : ['~/server/plugins/log-errors.ts']
}

// 生产环境禁用 sourcemap
build: {
  ...(mode === 'production' && {
    sourcemap: false, // 生产环境禁用sourcemap以节省内存
  })
}
```

#### Node.js 启动参数优化
```json
{
  "scripts": {
    "start": "NODE_OPTIONS=\"--max-old-space-size=4096 --expose-gc --optimize-for-size\" node .output/server/index.mjs"
  }
}
```

### 2. 日志系统优化

#### 错误日志系统 (`utils/errorLogger.ts`)
- 生产环境使用缓冲机制，避免过多日志输出
- 限制缓冲区大小，定期清理
- 只记录关键错误到控制台

#### 性能监控优化 (`plugins/performance.client.ts`)
- 生产环境完全禁用详细性能监控
- 只在开发环境启用性能监控

### 3. 组件内存管理

#### 定时器清理
```vue
<script setup>
const timer = ref(null)

onMounted(() => {
  timer.value = setInterval(() => {
    // 定时器逻辑
  }, 1000)
})

onUnmounted(() => {
  if (timer.value) {
    clearInterval(timer.value)
    timer.value = null
  }
})
</script>
```

#### 事件监听器清理
```vue
<script setup>
import { onUnmounted } from 'vue'

const handleScroll = () => {
  // 滚动处理逻辑
}

onMounted(() => {
  document.addEventListener('scroll', handleScroll)
})

onUnmounted(() => {
  document.removeEventListener('scroll', handleScroll)
})
</script>
```

#### 响应式数据清理
```vue
<script setup>
import { onUnmounted, watch, watchEffect } from 'vue'

const stopWatch = watch(data, () => {
  // 监听逻辑
})

const stopWatchEffect = watchEffect(() => {
  // 监听逻辑
})

onUnmounted(() => {
  stopWatch()
  stopWatchEffect()
})
</script>
```

### 4. 错误监控优化

#### 错误监控系统 (`utils/errorMonitoring.ts`)
- 添加自动清理机制，定期清理旧的监控数据
- 限制缓冲区大小，防止内存累积
- 优化数据结构和存储方式

### 5. 开发规范

#### 代码审查要点
1. 检查所有定时器是否在组件卸载时清理
2. 检查事件监听器是否正确移除
3. 检查 `watch` 和 `watchEffect` 是否在组件卸载时停止
4. 检查生产环境是否还有调试日志输出

#### 内存泄漏检测
```javascript
// 在开发环境中使用 Chrome DevTools 的 Memory 面板
// 1. 打开 Memory 面板
// 2. 选择 Heap snapshot
// 3. 执行操作（如页面切换、组件加载卸载）
// 4. 再次拍摄快照
// 5. 比较快照，查看是否有内存泄漏
```

## 监控和预防

### 1. 内存使用监控
- 使用 Node.js 的 `process.memoryUsage()` 监控内存使用
- 设置内存使用阈值告警
- 定期检查内存使用趋势

### 2. 性能监控
- 使用 APM 工具监控应用性能
- 监控垃圾回收频率和时间
- 监控内存分配模式

### 3. 代码质量
- 使用 ESLint 规则检查潜在的内存泄漏
- 定期进行代码审查
- 建立代码规范，确保内存管理最佳实践

## 部署建议

### 1. 生产环境配置
- 确保所有调试日志在生产环境中被禁用
- 使用适当的 Node.js 启动参数
- 配置合适的内存限制

### 2. 监控告警
- 设置内存使用率告警
- 监控应用崩溃和重启频率
- 建立性能基线

### 3. 定期维护
- 定期检查内存使用情况
- 更新依赖包以修复已知的内存泄漏问题
- 定期进行性能优化

## 总结

通过以上优化措施，可以有效解决内存泄漏问题：

1. **环境隔离**：开发环境和生产环境使用不同的配置
2. **日志控制**：生产环境减少不必要的日志输出
3. **资源清理**：确保所有资源在组件卸载时正确清理
4. **监控优化**：优化监控系统，避免监控本身造成内存泄漏
5. **规范建立**：建立代码规范，预防内存泄漏

这些措施应该能够显著改善应用的内存使用情况，避免内存溢出问题。

# <ClientOnly>包裹的组件是否影响服务端性能

以下是会导致问题的操作​：以下操作在服务端初始化阶段依然会执行，无论组件是否被 <ClientOnly>包裹：

• 在 setup(), created(), mounted()（mounted在服务端不会执行，但 created会）等生命周期中进行大量的数据计算或处理。

• 引入一个体积巨大的第三方库。

• 执行一个非常耗内存的初始化函数。

• 连接一个数据库或进行大量的网络 I/O（虽然这不常见于组件内）。

```ts
<script setup>
const MyChartComponent = defineAsyncComponent(() =>
  import('./MyChartComponent.vue')
);
</script>

<template>
  <ClientOnly>
    <MyChartComponent />
  </ClientOnly>
</template>
```

```ts
<script setup>
import { ref, onMounted } from 'vue';

const chartData = ref(null);

// 正确的做法：将数据获取和计算放在 onMounted 中
onMounted(() => {
  // 这个回调只会在客户端执行
  import('~/assets/huge-data.json').then((module) => {
    const hugeDataset = module.default;
    chartData.value = hugeDataset.map(item => {
      return { ...item, calculatedProperty: someHeavyCalculation(item) };
    });
  });
});

// 或者使用 process.client 标志
if (process.client) {
  // 这里的代码只会在客户端执行
}
</script>
```