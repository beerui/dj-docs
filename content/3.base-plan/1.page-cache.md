---
title: 商城Nuxt缓存方案
navigation:
  icon: i-lucide-database
---

本文介绍了商城项目的缓存设计方案，从方案选型到实施结束和二期租户改造。

## 可用方案

1.  Nitro的内置存储（基于文件）
    
2.  Redis（需要Redis服务器，在高流量下性能更优）
    
3.  内存（最快，但受服务器内存限制）
    

## 缓存范围

*   仅限公共/静态页面（主页、市场、产品列表、新闻）
    
*   手动选择：仅选择您指定的高流量页面（首页1.2mb，市场页共136个，每个320k，共42.5MB、类目页共500个，每个690k，共336MB、其它一级菜单6个，70k，共4.2mb，全部缓存共384MB）
    
*   语言：忽略，不缓存当前站点的其它语言
    

### 页面与接口

1. 公共接口缓存在Redis 减少后端访问压力
2. 常用页面访问缓存

缓存规则

::collapsible
```ts
// 包含缓存的路由模式
export const CACHE_INCLUDE_PATTERNS = [
  '/',
  '/market/**',
  '/mall/**',
  '/national-pavilion/**',
  '/outside-trade-serve/**',
  '/ai-tools/**',
  '/shop/**',
  '/government-services/**',
  '/service-market/**',
  '/goods-detail/**',
  '/about-us/**',
]

// 路径模式到TTL的映射（单位：秒）
// 匹配规则：按精确度选择最长匹配（更精确的模式优先）
// 缓存页面需要增加 data-cache="cache-correct-control" 接口请求成功后再缓存
export const CACHE_TTL_MAP: Record<string, number> = {
  '/': 28800,                    // 首页：8小时
  '/goods-detail/**': 3600 * 4,      // 商品详情：4小时
  '/market/**': 3600 * 24,           // 市场：24小时
  '/mall/**': 3600 * 4,             // 商城：4小时
  '/national-pavilion/**': 3600 * 24, // 国家馆：12小时
  '/outside-trade-serve/**': 3600 * 24, // 外贸服务：12小时
  '/ai-tools/**': 3600 * 24 * 7, // AI工具：7天
  '/shop/**': 3600 * 24, // 店铺：24小时
  '/government-services/**': 3600 * 24, // 政府服务：24小时
  '/service-market/**': 3600 * 24 * 7, // 服务市场：7天
  '/about-us/**': 3600 * 24 * 7, // 关于我们：7天
}

// 排除缓存的路由模式
export const CACHE_EXCLUDE_PATTERNS = [
  '^/auth',
  '^/merchants',
  '^/register-h5',
  '^/cart',
  '^/cashier',
  '^/debug',
  '^/mall/search-goods_0'
]
```
:: 

## 缓存键规则

缓存键格式：`GET:站点:AB目录:租户:(站点/API)_文件名`

:::prose-note
示例：
- `1:T0001:cn_page__`
- `1:T0001:mall_category_123`
:::
## 缓存存储对比 - 缓存应存储在何处？

*   Nitro的内置存储（重启后数据重置（非持久化）
    
*   Redis（需要Redis服务器，在高流量下性能更优，多实例可共享）
    
*   内存（最快，但受服务器内存限制，重启后数据重置）
    
::tip
客户端刷新策略：每次访问页面时自动刷新数据（在初始缓存HTML加载后获取最新数据）
::


## 客户端验证

客户端会在以下时机自动刷新数据：

1. 应用挂载后
2. 路由切换后
3. 页面包含标识 `data-cache="cache-correct-control"`

刷新机制：
- 使用 `refreshNuxtData()` 刷新当前页面数据
- 100ms 节流，避免频繁刷新
- 可通过页面 meta 禁用：`definePageMeta({ noClientRefresh: true })`

## 监控和调试

### 响应头

每个响应都会包含以下头信息：

- `x-ssr-cache: hit|miss` - 缓存命中状态
- `x-cache-key: ${key}` - 缓存键

## 缓存命中前后对比
![image.png](/img/page-cache-1.png)

![image.png](/img/page-cache-2.png)

![image.png](/img/page-cache-3.png)
![image.png](/img/page-cache-4.png)

## 服务器承载容量估算

生产环境：148272  上架商品

生产环境：340293  商品总数

服务器实例：硬盘容量为120G、内存容量为4G

| 数据项 | 数值 | 承载数 |
| --- | --- | --- |
| 单个列表页大小 | 大约700kb x 商品总数 | 6800页≈ 4.54GB |
| 单个详情页大小 | 大概200kb x 商品总数 ÷ 每页商品数 | 340000个≈ 64.8GB |
| 其它页面 | 未知kb x 100个活动页和一级页面 | ≈100MB |
| 总计 |  | ≈70GB ~ 100GB |

## 已完成待办

*   [x] Nuxt文件缓存提供接口清除，定时清除
    
*   [x] Nuxt文件缓存过期不会自动清理，设置缓存上限2000条
    
*   [x] Redis的HTML缓存冲突：重启，本地测试都会存在（已修改为文件缓存）
    
*   [x] 若页面错误也会被缓存，通过增加缓存判断来确定是否需要缓存 - 增加标识
    
*   [x] 非SSR页面会刷新两次接口的问题 - 增加标识
    
*   [x] 修改缓存逻辑，确保API请求失败时不缓存响应数据，避免缓存污染
    
*   [x] 根据页面配置差异化缓存时间
    
*   [x] curl请求已缓存页面也会导致接口请求的问题（实现方式错误，缓存页面后还会继续执行渲染）
    
*   [x] 详情部分组件刷新接口后内容未更新（使用computed来监听页面使用的值）
    
*   [x] 类目，缓存后刷新页面币种无变化（computed + 刷新接口）
    
*   [x] 英文站缓存击中的是主站（站点区分，目前不止区分站点）
    

## 项目部署的缓存冲突

::accordion

  :::accordion-item{label="共享缓存" icon="i-lucide-circle-help"}
  * 问题：每个服务实例都会执行一次缓存
  * 方案：使用共享NAS盘来解决缓存共用，保证一个服务缓存了 其他服务共用
  :::

  :::accordion-item{label="部署实例删除缓存导致404" icon="i-lucide-circle-help"}
  * 问题：部署实例导致缓存被删除，方案一：流水线删除 方案二：项目启动删除 方案三：旧容器退出时删除
  * 方案：其他方案会使旧缓存无效导致旧实例404，最终方案是：新容器启动十分钟后删除旧容器缓存，新容器启动时兜底清除当前缓存容器
  :::

  :::accordion-item{label="一份缓存对应两个实例" icon="i-lucide-circle-help"}
  * 问题: 项目部署时，删除旧实例P1缓存，存入新实例P2缓存，此时P1还可以访问，进入页面后命中P2的缓存，导致客户端加载资源404（共享NAS盘）
  * 方案: 一份缓存对应两个实例：项目部署时，删除旧实例P1缓存，存入新实例P2缓存，此时P1还可以访问，进入页面后命中P2的缓存，导致客户端加载资源404（共享NAS盘）
  :::

  :::accordion-item{label="多实例启动AB缓存判断" icon="i-lucide-circle-help"}
  * 问题：每次启动会自动切换AB目录，多实例下不可用，十分钟内部署的限制：会导致缓存目录不切换，缓存错位，新实例404，未达到十分钟的时候再次部署旧缓存未删除导致新启动目录404
  * 方案：十分钟计数：在缓存项目下记录第一次运行的时间，十分钟内不再切换AB目录
  :::

  :::accordion-item{label="重启清缓存" icon="i-lucide-circle-help"}
  * 问题：k8s重启时，会切换缓存文件夹导致缓存被删除，实际代码是一样的无需清除缓存
  * 方案：获取打包后的id比对，若相同则不清除缓存，不切换缓存目录
  :::
::

![image.png](/img/page-cache-5.png)

## 正式服第一次启动和重启

![image.png](/img/page-cache-6.png)

## 部分缓存的接口

Node端集合接口：`/api/init-data`

![image.png](/img/page-cache-7.png)

![image.png](/img/page-cache-8.png)

## 缓存具体实现
::field-group
  ::field{name="Redis" type="速度最快 可共享"}
    1. 从 Redis (`ssr-cache`) 读取缓存实体，命中目标接口后，缓存接口返回结果。
    2. 命中后调用 `touch(cacheKey, nationalType)` 更新 ZSET (`nuxt:{nationalType}:lru:ssr`)
  ::

  ::field{name="文件缓存" type="磁盘缓存"}
    命中目标路由后，缓存服务端渲染结果。
  ::

  ::field{name="LRU" type="Least Recently Used 竞争 逐出机制"}
    符合最近最少使用（LRU）缓存约束的数据结构
    - 当成员数 > capacity 时触发
    - 移除最久未访问的缓存键
    - 同步从 Redis 删除缓存实体
  ::

  ::field{name="TTL" type="Time to Live 时间区分"}
    缓存数据可存储多长时间后被刷新
    1. Nitro 将缓存实体写入文件系统 (`cache-fs`)，已修改为fs
    2. `render:response` 钩子
    3. 调用 `evictFSIfNeeded` 检查容量并逐出
  ::
::

## Redis

Redis连接账号密码，测试服的项目配置中已有。下载Redis管理软件，连接成功后即可查看存储信息。

正式服权限：联系运维开通DMS查看。

::caution
重要：
* Redis分区有严格的限制，前端使用的是分区12。
* Redis版本限制：Redis6.0.2版本，window推荐使用wsl安装。
* Redis部署：必须走内网请求。
::
### 1、 连接本地Redis开发

![image.png](./img/page-cache-9.png)

### 2、 打包后验证，如何连接本地Redis

找到打包后的Redis地址和密码 替换两处地方即可

![image.png](./img/page-cache-10.png)

## 页面缓存命中规则

```typescript
 * SSR 缓存配置和工具函数
 * 
 * 缓存验证机制（白名单模式）：
 * 1. 只缓存 HTTP 状态码 200-399 的响应
 * 2. 检查响应体大小（至少 500 字节）
 * 3. 🔥 【白名单】页面必须包含 data-cache="cache-correct-control" 标识才允许缓存
 * 4. 检查是否包含明显错误标记（CommonError404、"出错啦"等）
 * 
 * 如何使用：
 * 在页面模板中添加缓存控制标识：
 * <div data-cache="cache-correct-control">页面内容</div>
```

## Referer代理

- 服务端：请求头中携带Referer
- 客户端：本地代理，转发请求头中携带Referer

## 租户隔离

租户隔离的具体实现：[多租户架构指南](/nuxt/tenant) [租户使用指南](/nuxt/tenant-use)
- T0001
- T0002

## 站点隔离
- 大集商城PC 主站 https://dev.chinamarket.cn/
- 大集商城PC 英文站 http://global-dev.chinamarket.cn/
- 大集商城PC 香港站 https://hk-dev.chinamarket.cn/
- 大集商城PC 印度尼西亚站 https://idn-dev.chinamarket.cn/
- 大集商城PC 阿联酋站 https://uae-dev.chinamarket.cn/

## 页面缓存实现路线
### 刷新策略
- 首次访问：缓存文件到服务器中
- 后续访问：击中缓存，服务器不再计算
- 客户端表现：每次访问页面时自动刷新数据（在初始缓存HTML加载后获取最新数据）

### 缓存策略
- 初始缓存4小时，再次请求会返回缓存内容
- 重新部署会全部清空页面缓存
- 接口错误，或数据获取失败，不会缓存页面，避免缓存污染
- 缓存页面条数2000条，可以修改
- 请求头中可以查看缓存是否击中：x-page-cache：miss | hit
